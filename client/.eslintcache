[{"E:\\GDesign\\program\\client\\src\\components\\ScatterPlot.tsx":"1","E:\\GDesign\\program\\client\\src\\App.tsx":"2","E:\\GDesign\\program\\client\\src\\index.tsx":"3","E:\\GDesign\\program\\client\\src\\components\\ForceCompute.tsx":"4","E:\\GDesign\\program\\client\\src\\components\\NodeLink.tsx":"5","E:\\GDesign\\program\\client\\src\\reportWebVitals.ts":"6","E:\\GDesign\\program\\client\\src\\components\\NodeList.tsx":"7","E:\\GDesign\\program\\client\\src\\components\\Info.tsx":"8","E:\\GDesign\\program\\client\\src\\components\\Parallel.tsx":"9","E:\\GDesign\\program\\client\\src\\components\\Table.tsx":"10","E:\\GDesign\\program\\client\\src\\components\\DrawPanel.tsx":"11","E:\\GDesign\\program\\client\\src\\components\\DistributeAttr.tsx":"12","E:\\GDesign\\program\\client\\src\\components\\TargetTree.tsx":"13","E:\\GDesign\\program\\client\\src\\components\\PNodeLink.tsx":"14","E:\\GDesign\\program\\client\\src\\components\\ellipseForce.js":"15","E:\\GDesign\\program\\client\\src\\components\\PTargetTree.tsx":"16","E:\\GDesign\\program\\client\\src\\components\\HistoryRecord.tsx":"17","E:\\GDesign\\program\\client\\src\\components\\http.ts":"18"},{"size":25795,"mtime":1617016067410,"results":"19","hashOfConfig":"20"},{"size":25280,"mtime":1617020470583,"results":"21","hashOfConfig":"20"},{"size":457,"mtime":1611729263800,"results":"22","hashOfConfig":"20"},{"size":4336,"mtime":1617014493500,"results":"23","hashOfConfig":"20"},{"size":6960,"mtime":1616918791941,"results":"24","hashOfConfig":"20"},{"size":425,"mtime":1609982263790,"results":"25","hashOfConfig":"20"},{"size":3073,"mtime":1617016142886,"results":"26","hashOfConfig":"20"},{"size":5813,"mtime":1617022004305,"results":"27","hashOfConfig":"20"},{"size":19322,"mtime":1617017644991,"results":"28","hashOfConfig":"20"},{"size":3089,"mtime":1617028460484,"results":"29","hashOfConfig":"20"},{"size":15383,"mtime":1617004029310,"results":"30","hashOfConfig":"20"},{"size":8938,"mtime":1616247858859,"results":"31","hashOfConfig":"20"},{"size":3268,"mtime":1616918885930,"results":"32","hashOfConfig":"20"},{"size":9998,"mtime":1617031383018,"results":"33","hashOfConfig":"20"},{"size":5702,"mtime":1615529771241,"results":"34","hashOfConfig":"20"},{"size":18209,"mtime":1616940158459,"results":"35","hashOfConfig":"20"},{"size":4065,"mtime":1617020365531,"results":"36","hashOfConfig":"20"},{"size":1108,"mtime":1616341734386,"results":"37","hashOfConfig":"20"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"pde34m",{"filePath":"40","messages":"41","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"47","messages":"48","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"49","messages":"50","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"51"},{"filePath":"52","messages":"53","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"54","messages":"55","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"56","messages":"57","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"58","messages":"59","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"60","messages":"61","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"62","messages":"63","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"64"},{"filePath":"65","messages":"66","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"67","messages":"68","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"69","messages":"70","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"71"},{"filePath":"72","messages":"73","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"74","messages":"75","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"76","messages":"77","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"E:\\GDesign\\program\\client\\src\\components\\ScatterPlot.tsx",[],"E:\\GDesign\\program\\client\\src\\App.tsx",["78"],"E:\\GDesign\\program\\client\\src\\index.tsx",[],["79","80"],"E:\\GDesign\\program\\client\\src\\components\\ForceCompute.tsx",["81","82"],"E:\\GDesign\\program\\client\\src\\components\\NodeLink.tsx",["83"],"E:\\GDesign\\program\\client\\src\\reportWebVitals.ts",[],["84","85"],"E:\\GDesign\\program\\client\\src\\components\\NodeList.tsx",["86"],"E:\\GDesign\\program\\client\\src\\components\\Info.tsx",["87","88"],"E:\\GDesign\\program\\client\\src\\components\\Parallel.tsx",["89","90","91"],"E:\\GDesign\\program\\client\\src\\components\\Table.tsx",[],"E:\\GDesign\\program\\client\\src\\components\\DrawPanel.tsx",[],"E:\\GDesign\\program\\client\\src\\components\\DistributeAttr.tsx",["92"],"import * as React from 'react';\r\nimport axios from 'axios';\r\nimport * as d3 from 'd3';\r\n\r\ntype attr = {\r\n    [propName: string]: any,\r\n}\r\n\r\ninterface Props {\r\n    url: string,\r\n    parent: any,\r\n    dimensions: number,\r\n    attrWeight: number,\r\n    strWeight: number,\r\n    attrChecked: attr,\r\n    choosePoints: Array<ChoosePointData>,//匹配的数据\r\n    centerPoint: ChoosePointData,\r\n    display: string,\r\n    dataType: string,\r\n    graphType: string,//结构还是属性\r\n    x: string,//x轴字段\r\n    y: string,//y轴字段\r\n    personGraphs:Array<attr>,\r\n}\r\n//定义边数组\r\ntype edges = Array<number>;\r\n//定义散点数据接口\r\ntype ChoosePointData = {\r\n    id: number,\r\n    // nodes: Array<number>,\r\n    // edges:Array<edges>,\r\n    [propName: string]: any,\r\n}\r\nclass DistributeAttr extends React.Component<Props, any>{\r\n\r\n    private svgRef: React.RefObject<SVGSVGElement>;\r\n    public padding = { top: 20, bottom: 30, left: 30, right: 20 };\r\n    public svgWidth: number = 0;\r\n    public svgHeight: number = 0;\r\n    public lightColor: string = 'orange';\r\n    public centerColor: string = 'red';\r\n    constructor(props: Props) {\r\n        super(props);\r\n        this.state = { data: [], choosePoints: [], centerPoint: null };\r\n        this.svgRef = React.createRef();\r\n        this.compute = this.compute.bind(this);\r\n        this.searchGraph = this.searchGraph.bind(this);\r\n    }\r\n\r\n    compute(data: any, xAttr: string, yAttr: string): void {\r\n        const { graphType } = this.props;\r\n        let x_min_max = d3.extent(data, (d: any) => d[graphType][xAttr]);\r\n        // x_min_max[0]=0;\r\n        let y_min_max = d3.extent(data, (d: any) => d[graphType][yAttr]);\r\n        // y_min_max[0]=0;\r\n        let xscale = d3.scaleLinear(x_min_max, [this.padding.left, this.svgWidth - this.padding.right]);\r\n        let yscale = d3.scaleLinear(y_min_max, [this.svgHeight - this.padding.bottom, this.padding.top]);\r\n\r\n        data.forEach((value: any) => {\r\n            value.x = xscale(value[graphType][xAttr]);\r\n            value.y = yscale(value[graphType][yAttr]);\r\n        });\r\n\r\n        d3.select(\"#svg_\" + graphType)\r\n            .select(\".axis\")\r\n            .selectAll(\"g\")\r\n            .remove();\r\n        d3.select(\"#svg_\" + graphType)\r\n            .select(\".text\")\r\n            .selectAll(\"g\")\r\n            .remove();\r\n\r\n        d3.select(\"#svg_\" + graphType)\r\n            .select(\".axis\")\r\n            .append(\"g\")\r\n            .attr(\"transform\", `translate(-2,${this.svgHeight - this.padding.bottom + 2})`)\r\n            .call(d3.axisBottom(xscale).ticks(8))\r\n        d3.select(\"#svg_\" + graphType)\r\n            .select(\".axis\")\r\n            .append(\"g\")\r\n            .attr(\"transform\", `translate(${this.padding.left - 2},2)`)\r\n            .call(d3.axisLeft(yscale).ticks(5))\r\n\r\n        this.setState({ data: data });\r\n\r\n    }\r\n    \r\n    searchGraph(pointData: ChoosePointData): void {//根据名字搜索包含该节点的网络\r\n        const { url, dimensions, attrWeight, strWeight, attrChecked, dataType } = this.props;\r\n        let checkedArr: any = [];\r\n        for (let key in attrChecked) {\r\n            checkedArr.push({ name: key, value: attrChecked[key] })\r\n        }\r\n        axios.post(url + '/searchGraphByGraphId', { wd: pointData.id, dataType: dataType, dimensions: dimensions, attrWeight: attrWeight, strWeight: strWeight, attrChecked: checkedArr })\r\n            .then(res => {\r\n                // console.log(res.data.data);\r\n                this.props.parent.setPersonGraphs(res.data.data);\r\n            })\r\n        this.setState({ centerPoint: pointData });\r\n    }\r\n\r\n    componentDidMount(): void {\r\n        this.svgWidth = this.svgRef.current?.clientWidth || 0;\r\n        this.svgHeight = this.svgRef.current?.clientHeight || 0;\r\n\r\n    }\r\n    componentWillReceiveProps(nextProps: Props): void {\r\n        if (nextProps.choosePoints !== this.props.choosePoints) {\r\n            let choosePoints = [];\r\n            for (let j in nextProps.choosePoints) {\r\n                for (let i in this.state.data) {\r\n                    if (this.state.data[i].id === nextProps.choosePoints[j].id) {\r\n                        choosePoints.push(this.state.data[i]);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            this.setState({ choosePoints: choosePoints });\r\n        }\r\n        if (nextProps.centerPoint !== this.props.centerPoint) {\r\n            for (let i in this.state.data) {\r\n                if (this.state.data[i].id === nextProps.centerPoint.id) {\r\n                    this.setState({ centerPoint: this.state.data[i] });\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (nextProps.attrChecked !== this.props.attrChecked && nextProps.x!=='') {\r\n            const { url, dimensions, attrWeight, strWeight, attrChecked, dataType } = nextProps;\r\n            let checkedArr: any = [];\r\n            for (let key in attrChecked) {\r\n                checkedArr.push({ name: key, value: attrChecked[key] })\r\n            }\r\n            axios.post(url, { dataType: dataType, dimensions: dimensions, attrWeight: attrWeight, strWeight: strWeight, attrChecked: checkedArr })\r\n                .then(res => {\r\n                    const data = res.data.data;\r\n                    let { x, y } = nextProps;\r\n                    this.compute(data, x, y);\r\n                })\r\n        }\r\n        if ((nextProps.x !== this.props.x || nextProps.y !== this.props.y)) {\r\n            const { data } = this.state;\r\n            const { x, y } = nextProps;\r\n\r\n            if (data.length > 0) {\r\n                    this.compute(data, x, y);    \r\n            }\r\n            else{\r\n                \r\n                const { url, dimensions, attrWeight, strWeight, attrChecked, dataType } = nextProps;\r\n                let checkedArr: any = [];\r\n                for (let key in attrChecked) {\r\n                    checkedArr.push({ name: key, value: attrChecked[key] })\r\n                }\r\n                axios.post(url, { dataType: dataType, dimensions: dimensions, attrWeight: attrWeight, strWeight: strWeight, attrChecked: checkedArr })\r\n                    .then(res => {\r\n                        const data = res.data.data;\r\n                        let { x, y } = nextProps;\r\n                        this.compute(data, x, y);\r\n                    })\r\n            }\r\n        }\r\n        if(nextProps.dataType!==this.props.dataType){\r\n            this.setState({data:[],centerPoint:null,choosePoints:[]});\r\n        }\r\n\r\n    }\r\n\r\n\r\n    render(): React.ReactElement {\r\n        const { data, centerPoint, choosePoints} = this.state;\r\n        const {x,y,display,graphType,personGraphs} = this.props;\r\n        let allPointEl = data.map((value: any, index: number) =>\r\n            <circle key={index} cx={value.x} cy={value.y} r='2px' fill='#1890ff' fillOpacity={0.4} stroke='white' strokeWidth='0.5px'\r\n                onClick={this.searchGraph.bind(this, value)}></circle>\r\n        )\r\n        \r\n        //centerPoint\r\n        //点击的点，需要匹配的点\r\n        let centerPointEl = null;\r\n        if (centerPoint != null) {\r\n            centerPointEl = <circle r=\"2px\" cx={centerPoint.x} cy={centerPoint.y} fill={this.centerColor} stroke='white' strokeWidth='0.5px'\r\n                onClick={this.searchGraph.bind(this, centerPoint)}></circle>\r\n        }\r\n        //圈选的点，匹配到的点\r\n        let pointsChooseEl = choosePoints.map((value: ChoosePointData, index: number) =>\r\n            <circle r=\"2px\" cx={value.x} cy={value.y} key={index} fill={this.lightColor} stroke='white' strokeWidth='0.5px'\r\n                onClick={this.searchGraph.bind(this, value)}></circle>\r\n        )\r\n\r\n        //点击的点，试选阶段\r\n        let persongraphs = personGraphs.map((value: any, index: number) =>{\r\n            for(let i=0;i<data.length;i++){\r\n                if(data[i].id===value.id){\r\n                    return <circle r=\"2px\" cx={data[i].x} cy={data[i].y} key={index} fill={this.centerColor} stroke='white' strokeWidth='0.5px'\r\n                    onClick={this.searchGraph.bind(this, value)}></circle>\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n        )\r\n\r\n        return (\r\n            <div className=\"distributeAttr\" style={{ position: 'absolute', left: display === '0' ? '-100%' : '0' }}>\r\n                \r\n                <svg style={{ width: '100%', height: '100%' }} ref={this.svgRef} id={'svg_' + graphType}>\r\n                    <g className=\"axis\"></g>\r\n                    <g className=\"text\"></g>\r\n                    <text x={this.svgWidth-50} y={this.svgHeight-40}>{x}</text>\r\n                    <text x='5px' y='15px'>{y}</text>\r\n                    {allPointEl}\r\n                    {pointsChooseEl}\r\n                    {centerPointEl}\r\n                    {persongraphs}\r\n                </svg>\r\n            </div>\r\n        )\r\n    }\r\n}\r\nexport default DistributeAttr;","E:\\GDesign\\program\\client\\src\\components\\TargetTree.tsx",[],"E:\\GDesign\\program\\client\\src\\components\\PNodeLink.tsx",["93","94"],"E:\\GDesign\\program\\client\\src\\components\\ellipseForce.js",["95","96","97","98","99","100"],"function constant(x) {\n  return function() {\n    return x;\n  };\n}\n\nexport default function (padding, innerRepulsion, outerRepulsion) {\n  var nodes;\n  \n  if (typeof padding !== \"function\") padding = constant(padding == null ? 4 : +padding);\n  innerRepulsion = innerRepulsion == null ? 0.5 : +innerRepulsion;\n  outerRepulsion = outerRepulsion == null ? 0.5 : +outerRepulsion;\n\n  function force(alpha) {\n    var i, j, n = nodes.length,\n        // dimensions of this node\n        node, my_padding, my_w, my_h, my_x, my_y,\n        // often used multiples\n        my_w2, my_h2, my_wh,\n        // dimensions of the other node \n        other, other_padding, other_w, other_h, other_x, other_y,\n        // distance between nodes\n        dist_x, dist_y,\n        // components for the overall result\n        force_ratio, dist, gap, repulsion, x_component, y_component,\n        // computing elliptical force \n        g, g2, x1, y1, x2, y2, d1, d2,\n        force_ratio1, force_ratio2,\n        // parameters\n        myOuterRepulsion = outerRepulsion * 16;\n\n    for (i = 0; i < n; ++i) {\n      node = nodes[i];\n      my_padding = +padding(node, i, nodes);\n      my_w = node.rx + my_padding;\n      my_h = node.ry + my_padding;\n      my_w2 = my_w * my_w;\n      my_h2 = my_h * my_h;\n      my_wh = my_w * my_h;\n      my_x = node.x + node.vx;\n      my_y = node.y + node.vy;\n\n      for (j = 0; j < n; ++j) {\n          if (j == i) {\n              continue;             \n          }\n          other = nodes[j];\n          other_padding = +padding(other, j, nodes);\n          other_w = other.rx + other_padding;\n          other_h = other.ry + other_padding;\n          other_x = other.x + other.vx;\n          other_y = other.y + other.vy;\n          dist_x = my_x - other_x;\n          dist_y = my_y - other_y;\n          if (dist_x == 0 && dist_y == 0) {\n              node.vx += (Math.random() * 4) - 2;\n              node.vy += (Math.random() * 4) - 2;  \n              continue;            \n          } else if (dist_x == 0) {\n              force_ratio = (my_h / my_w + other_h / other_w) / 2;\n              dist = Math.abs(dist_y);\n              gap = dist - my_h - other_h;\n          } else if (dist_y == 0) {\n              force_ratio = 1;\n              dist = Math.abs(dist_x);\n              gap = dist - my_w - other_w;\n          } else {\n              // ellipse is defined as  x^2   y^2\n              //                        --- + --- = 1\n              //                        w^2   h^2\n              // here x,y are points on ellipse's arc. \n              // we have a line going between center points of two ellipses and we want to know\n              // the point where it crosses the ellipse's arc. Because we know the line, we\n              // know that y = g * x, where    \n              g = dist_y / dist_x;\n              // now the only unknown in ellipse above is x, and thus we can find it by  \n              // moving pieces around (pen and paper work). equation becomes: \n              //             w * h\n              // x = ---------------------\n              //     sqrt(h^2 + g^2 * w^2)\n\n              g2 = g * g;\n              x1 = my_wh / Math.sqrt(my_h2 + g2 * my_w2);\n              y1 = g * x1;\n              // the length of the little bit from the center of ellipse to its margin. \n              // For circle it would be 'r', but for ellipse it varies. \n              d1 = Math.sqrt(x1 * x1 + y1 * y1);\n              // Strength of force that this ellipse eminates is modified by ratio of this bit \n              // to the ellipse's width. (It doesn't matter if we use width or height as reference\n              // point)  \n              force_ratio1 = d1 / my_w;\n              // And same for the other ellipse:\n              x2 = (other_w * other_h) / Math.sqrt(other_h * other_h + g2 * other_w * other_w)\n              y2 = g * x2\n              d2 = Math.sqrt(x2 * x2 + y2 * y2);\n              force_ratio2 = d2 / other_w;\n              // now we can calculate the gap or overlap between two ellipses, and force ratio on \n              // how strongly they should push as average of their force_ratios\n              dist = Math.sqrt(dist_x * dist_x + dist_y * dist_y);\n              gap = dist - d2 - d1;\n              force_ratio = (force_ratio1 + force_ratio2) / 2;\n          }\n          x_component = dist_x / dist;\n          y_component = dist_y / dist;\n          if (gap < 0) { // force GROWS as gap goes further into negative\n              repulsion = Math.min(Math.max(1.0, innerRepulsion * force_ratio * -gap), 5.0);\n              node.vx += repulsion * x_component;\n              node.vy += repulsion * y_component;              \n          } else { // force DIMINISHES as gap becomes larger\n              repulsion = Math.min(20.0, (force_ratio * myOuterRepulsion * alpha) / gap)\n              node.vx += repulsion * x_component\n              node.vy += repulsion * y_component\n          }\n      }\n    }\n  }\n\n  force.initialize = function(my_nodes) {\n    nodes = my_nodes;\n  };\n\n  force.outerRepulsion = function(my_outerRepulsion) {\n    if (arguments.length) {\n      outerRepulsion = +my_outerRepulsion;\n      return force;\n    } else {\n      return outerRepulsion;\n    }\n  };\n\n  force.innerRepulsion = function(my_innerRepulsion) {\n    if (arguments.length) {\n      innerRepulsion = +my_innerRepulsion;\n      return force;\n    } else {\n      return innerRepulsion;\n    }\n  };\n\n  force.padding = function(my_padding) {\n    if (arguments.length) {\n      if (typeof my_padding  === \"function\") {\n        padding = my_padding;\n      } else {\n        padding = constant(+my_padding);\n      }      \n      return force;\n    } else {\n      return padding;\n    }\n  };\n\n\n  return force;\n}\n","E:\\GDesign\\program\\client\\src\\components\\PTargetTree.tsx",[],"E:\\GDesign\\program\\client\\src\\components\\HistoryRecord.tsx",["101"],"E:\\GDesign\\program\\client\\src\\components\\http.ts",[],{"ruleId":"102","severity":1,"message":"103","line":20,"column":6,"nodeType":"104","messageId":"105","endLine":20,"endColumn":11},{"ruleId":"106","replacedBy":"107"},{"ruleId":"108","replacedBy":"109"},{"ruleId":"110","severity":1,"message":"111","line":64,"column":81,"nodeType":"112","messageId":"113","endLine":64,"endColumn":83},{"ruleId":"110","severity":1,"message":"111","line":85,"column":81,"nodeType":"112","messageId":"113","endLine":85,"endColumn":83},{"ruleId":"102","severity":1,"message":"114","line":131,"column":40,"nodeType":"104","messageId":"105","endLine":131,"endColumn":49},{"ruleId":"106","replacedBy":"115"},{"ruleId":"108","replacedBy":"116"},{"ruleId":"102","severity":1,"message":"117","line":54,"column":15,"nodeType":"104","messageId":"105","endLine":54,"endColumn":21},{"ruleId":"102","severity":1,"message":"118","line":70,"column":52,"nodeType":"104","messageId":"105","endLine":70,"endColumn":58},{"ruleId":"119","severity":1,"message":"120","line":96,"column":21,"nodeType":"121","endLine":96,"endColumn":168},{"ruleId":"102","severity":1,"message":"122","line":106,"column":17,"nodeType":"104","messageId":"105","endLine":106,"endColumn":27},{"ruleId":"123","severity":1,"message":"124","line":249,"column":90,"nodeType":"125","messageId":"126","endLine":249,"endColumn":92},{"ruleId":"102","severity":1,"message":"127","line":300,"column":21,"nodeType":"104","messageId":"105","endLine":300,"endColumn":22},{"ruleId":"102","severity":1,"message":"103","line":26,"column":6,"nodeType":"104","messageId":"105","endLine":26,"endColumn":11},{"ruleId":"102","severity":1,"message":"128","line":123,"column":28,"nodeType":"104","messageId":"105","endLine":123,"endColumn":39},{"ruleId":"110","severity":1,"message":"111","line":197,"column":59,"nodeType":"112","messageId":"113","endLine":197,"endColumn":61},{"ruleId":"129","severity":1,"message":"130","line":7,"column":1,"nodeType":"131","endLine":155,"endColumn":2},{"ruleId":"123","severity":1,"message":"132","line":44,"column":17,"nodeType":"125","messageId":"126","endLine":44,"endColumn":19},{"ruleId":"123","severity":1,"message":"132","line":55,"column":22,"nodeType":"125","messageId":"126","endLine":55,"endColumn":24},{"ruleId":"123","severity":1,"message":"132","line":55,"column":37,"nodeType":"125","messageId":"126","endLine":55,"endColumn":39},{"ruleId":"123","severity":1,"message":"132","line":59,"column":29,"nodeType":"125","messageId":"126","endLine":59,"endColumn":31},{"ruleId":"123","severity":1,"message":"132","line":63,"column":29,"nodeType":"125","messageId":"126","endLine":63,"endColumn":31},{"ruleId":"110","severity":1,"message":"111","line":63,"column":51,"nodeType":"112","messageId":"113","endLine":63,"endColumn":53},"@typescript-eslint/no-unused-vars","'edges' is defined but never used.","Identifier","unusedVar","no-native-reassign",["133"],"no-negated-in-lhs",["134"],"array-callback-return","Array.prototype.map() expects a value to be returned at the end of arrow function.","ArrowFunctionExpression","expectedAtEnd","'focusNode' is assigned a value but never used.",["133"],["134"],"'suffix' is assigned a value but never used.","'parent' is assigned a value but never used.","jsx-a11y/alt-text","img elements must have an alt prop, either with meaningful text, or an empty string for decorative images.","JSXOpeningElement","'colorScale' is assigned a value but never used.","eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected","'c' is assigned a value but never used.","'layOutLinks' is assigned a value but never used.","import/no-anonymous-default-export","Unexpected default export of anonymous function","ExportDefaultDeclaration","Expected '===' and instead saw '=='.","no-global-assign","no-unsafe-negation"]